# 思路分析
## 秘诀
所谓最优算法，就是如下：
1. 针对特定问题，该算法没有告诉任何多余信息(比如，要最大值，不需要排序，因为那还告诉了第二大、三大等多余信息)
2. 问题本身特性，被充分挖掘(比如，有序数组查找某值，就可以二叉查找，而不是遍历，因为前者充分利用的数据的有序性)
## 注意事项
- 切记每个变量的含义，以及维护其合法性。
- 边界条件，一定不能失效。
## 复杂度分析
### 数据规模问题
## 数组问题
### 快排应用
#### 常规partion
283 26 80 27 75 几题，均为快排一次partion的应用。
此种问题，具有以下共同特征：
1. 可以进行顺序遍历。如26 80是顺序，283 27 是找是否相等，也可顺序遍历。
2. 均能将数组，分成两部分，即[0, i]、[i + 1, j)
据此，这种问题可以可以通过一次partion操作完成。
另外，根据[i + 1, j)区间是否需要维护，有可以分为赋值、交换。
#### 三路快排
稍有不同的是，75号题目，只有三种元素，就可以通过赋值避免交换.

**75题，用常规三路快排时，交换数据，需要当心，有坑，不能直接进行赋值0 1的，不然开始的边界条件不能满足**
如下：
```
        while (index < nums.length && index < r) {
            if (nums[index] == 0) {
                l++;
                nums[l] = 0;
                //错误，会把原本的值冲掉
                nums[index] = 1;
                index ++;
            } else if (nums[index] == 2) {
                r--;
                nums[index] = nums[r];
                nums[r] = 2;
            } else {
                index ++;
            }
        }
        
       while (index < nums.length && index < r) {
            if (nums[index] == 0) {
                int swap = nums[l + 1];
                nums[l + 1] = nums[index];
                nums[index] = swap;
                l ++;
                index ++;
            } else if (nums[index] == 2) {
                r--;
                nums[index] = nums[r];
                nums[r] = 2;
            } else {
                index ++;
            }
        }
```

#### 三路快排找第N大
215题，一气呵成，成就感呀。一定要做好边界判断。



### 计数排序应用
75题，可以使用计数排序

### 归并排序应用
88号题，典型的归并排序应用。需要变通的点，就是先排大。而不是常规的先排小。

### 二分查找问题
167号，典型的二分查找问题。需要主要的是，其边界条件，需要维护好


### 双索引-对撞指针
1. 167号，典型对撞指针解法。
2. 125 同样需要注意的问题，就是边界问题，字符串边界，也很脆弱，要时刻注意保持
3. 344，简直是在调戏智商
4. 345，对撞指针，字符串的操作，有点蠢，转正字符数组进行中间操作，进行了优化
5. 11，重点是理解其中的操作思想，装最多的水，怎么移动这个滑动窗口
### 双索引-滑动窗口

0. 需要注意以下三点：
   1. 起始条件，即滑动串口初识态如何定义
   2. 结束条件，即如何结束循环
      1. 左边界、还是有边界
   3. 滑动窗口如何更新：两种应该先更新那个
      1. 更新右边界
      2. 更新左边界
   4. 如何判断有效值


1. 209题， 花了2个小时才弄出来。主要是边界条件。这个初识边界的设置，要注意怎么和while循环保持一致。
   1. 但实际上，有更优雅的做法，即V1版本。
      1. 首先，[0, -1]的初识条件，让边界条件更好的维护
      2. while里判断i,而不是j，简化了内选循环的操作。实际上，就是找到了粒度更细、更本质、更简介的的操作单元
2. 3号题，就是209号题的孪生题，解题思路完全一致。注意体会 while 内部，if/else。越想越精妙
3. 438号题，这题是变种的滑动窗口。主要需要注意的点如下：
   1. 检查子字符串是否一致，使用freq[]数组
   2. 都是小写字母，所以使用-'a'。只用使用26个空间
   3. 到了最需要注意的地方了
      1. 终止条件，用j，而不是i，因为到j就可以结束了
      2. 每次都更新右边界，与终止条件遥相呼应
      3. 更新完右边界后，看下左边界在更新
      4. 左右更新完之后，再判断是否有效值
4. 在有了前几题的基础上，看hard的76题，就好理解的多了，基本上和438号题一模一样。但我仍花费了比预期多的时间，主要是还是思路不够严谨，有bug。整理如下：
   1. 初始条件几乎一样，暂且不表
   2. 先更新j
   3. 判断是否有效
   4. 更新做边界

## 查找问题
### 普通查找
1. 349，没啥，就是数据下api。
```java
leftSet.retainAll(rightSet);
leftSet.stream().mapToInt(Integer::intValue).toArray()
        res.stream().mapToInt(Integer::valueOf).toArray()

```
2. 350，熟悉下map api，没啥
3. 242，字符串中的字符操作，利用计数排序思想


## 链表
链表问题，最重要的是找好每次操作的单元
### 反转链表
1. 206 最简单的链表反转问题
注意其初识、边界、更新的操作，有时可以起到事半功倍的效果。但一定要保证每次操作都有效。
比如：
- 初识cur没指向pre，所以最后返回的头结点是pre
- 只用检查cur不为空
- 这样子，连非空判断的逻辑都包含了
```java
        //注意，初识状态cur 并没指向pre
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            //防止丢失
            ListNode next = cur.next;
            //交换位置
            cur.next = pre;
            //更新变量
            pre = cur;
            cur = next;
        }
        return pre;
```



## 递归
递归最最重要的两点：1. 递归终止条件；2. 递归过程
### 朴素递归
1. 104 体现递归的精髓
2. 302 仍是
3. 100 仍是
### 需要十分注意终止条件
4. 112 注意递归终止的条件。题意说的到叶子节点
