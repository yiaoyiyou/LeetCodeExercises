# 思路分析
## 秘诀
所谓最优算法，就是如下：
1. 针对特定问题，该算法没有告诉任何多余信息(比如，要最大值，不需要排序，因为那还告诉了第二大、三大等多余信息)
2. 问题本身特性，被充分挖掘(比如，有序数组查找某值，就可以二叉查找，而不是遍历，因为前者充分利用的数据的有序性)
## 注意事项
- 切记每个变量的含义，以及维护其合法性。
- 边界条件，一定不能失效。
## 复杂度分析
### 数据规模问题
## 数组问题
### 快排应用
#### 常规partion
283 26 80 27 75 几题，均为快排一次partion的应用。
此种问题，具有以下共同特征：
1. 可以进行顺序遍历。如26 80是顺序，283 27 是找是否相等，也可顺序遍历。
2. 均能将数组，分成两部分，即[0, i]、[i + 1, j)
据此，这种问题可以可以通过一次partion操作完成。
另外，根据[i + 1, j)区间是否需要维护，有可以分为赋值、交换。
#### 三路快排
稍有不同的是，75号题目，只有三种元素，就可以通过赋值避免交换.

**75题，用常规三路快排时，交换数据，需要当心，有坑，不能直接进行赋值0 1的，不然开始的边界条件不能满足**
如下：
```
        while (index < nums.length && index < r) {
            if (nums[index] == 0) {
                l++;
                nums[l] = 0;
                //错误，会把原本的值冲掉
                nums[index] = 1;
                index ++;
            } else if (nums[index] == 2) {
                r--;
                nums[index] = nums[r];
                nums[r] = 2;
            } else {
                index ++;
            }
        }
        
       while (index < nums.length && index < r) {
            if (nums[index] == 0) {
                int swap = nums[l + 1];
                nums[l + 1] = nums[index];
                nums[index] = swap;
                l ++;
                index ++;
            } else if (nums[index] == 2) {
                r--;
                nums[index] = nums[r];
                nums[r] = 2;
            } else {
                index ++;
            }
        }
```

#### 三路快排找第N大
215题，一气呵成，成就感呀。一定要做好边界判断。



### 计数排序应用
75题，可以使用计数排序

### 归并排序应用
88号题，典型的归并排序应用。需要变通的点，就是先排大。而不是常规的先排小。

### 二分查找问题
167号，典型的二分查找问题。需要主要的是，其边界条件，需要维护好


### 双索引-对撞指针
1. 167号，典型对撞指针解法。
2. 125 同样需要注意的问题，就是边界问题，字符串边界，也很脆弱，要时刻注意保持
3. 344，简直是在调戏智商
4. 345，对撞指针，字符串的操作，有点蠢，转正字符数组进行中间操作，进行了优化
5. 11，重点是理解其中的操作思想，装最多的水，怎么移动这个滑动窗口
### 双索引-滑动窗口

0. 需要注意以下三点：
   1. 起始条件，即滑动串口初识态如何定义
   2. 结束条件，即如何结束循环
      1. 左边界、还是有边界
   3. 滑动窗口如何更新：两种应该先更新那个
      1. 更新右边界
      2. 更新左边界
   4. 如何判断有效值


1. 209题， 花了2个小时才弄出来。主要是边界条件。这个初识边界的设置，要注意怎么和while循环保持一致。
   1. 但实际上，有更优雅的做法，即V1版本。
      1. 首先，[0, -1]的初识条件，让边界条件更好的维护
      2. while里判断i,而不是j，简化了内选循环的操作。实际上，就是找到了粒度更细、更本质、更简介的的操作单元
2. 3号题，就是209号题的孪生题，解题思路完全一致。注意体会 while 内部，if/else。越想越精妙
3. 438号题，这题是变种的滑动窗口。主要需要注意的点如下：
   1. 检查子字符串是否一致，使用freq[]数组
   2. 都是小写字母，所以使用-'a'。只用使用26个空间
   3. 到了最需要注意的地方了
      1. 终止条件，用j，而不是i，因为到j就可以结束了
      2. 每次都更新右边界，与终止条件遥相呼应
      3. 更新完右边界后，看下左边界在更新
      4. 左右更新完之后，再判断是否有效值
4. 在有了前几题的基础上，看hard的76题，就好理解的多了，基本上和438号题一模一样。但我仍花费了比预期多的时间，主要是还是思路不够严谨，有bug。整理如下：
   1. 初始条件几乎一样，暂且不表
   2. 先更新j
   3. 判断是否有效
   4. 更新做边界

## 查找问题
### 普通查找
1. 349，没啥，就是数据下api。
```java
leftSet.retainAll(rightSet);
leftSet.stream().mapToInt(Integer::intValue).toArray()
        res.stream().mapToInt(Integer::valueOf).toArray()

```
2. 350，熟悉下map api，没啥
3. 242，字符串中的字符操作，利用计数排序思想


## 链表
链表问题，最重要的是找好每次操作的单元
### 反转链表
1. 206 最简单的链表反转问题
注意其初识、边界、更新的操作，有时可以起到事半功倍的效果。但一定要保证每次操作都有效。
比如：
- 初识cur没指向pre，所以最后返回的头结点是pre
- 只用检查cur不为空
- 这样子，连非空判断的逻辑都包含了
```java
        //注意，初识状态cur 并没指向pre
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            //防止丢失
            ListNode next = cur.next;
            //交换位置
            cur.next = pre;
            //更新变量
            pre = cur;
            cur = next;
        }
        return pre;
```



## 递归
递归最最重要的两点：1. 递归终止条件；2. 递归过程
### 朴素递归
1. 104 体现递归的精髓
2. 302 仍是
3. 100 仍是
4. jz55 后序遍历
### 需要十分注意终止条件
4. 112 注意递归终止的条件。题意说的到叶子节点，注意，要判断什么是叶子节点
5. 404 也是，让判断左侧叶子节点，注意递归终止的条件
### 需要十分注意下递归循环的过程
6. 257 这题，精妙之处就是递归循环过程。难点在于怎么把每个路径结果都保存。
   思考过程如下：
   1. 递归到底两种情况
      1. 非空判断
      2. 到了子节点，塞进去
   2. 递归过程
      1. 把子节点结果，加进去
7. 437题。一开始不知道如何下手，就是把问题分治，然后各个击破
   需要注意的点，把当前节点刨除计算路径，有些技巧性
### 搜索树
8. 235 利用搜索树特点，找二叉树父节点


## 回溯法
回溯时，递归调用用个很重要的特点，就是每次调用，都要返回到上层进行处理
回溯一般指的查找 
### 排列问题
1. 17 注意其中的回溯过程。
2. 40 排列
   处理排列问题时，要注意几点：
   1. 回溯后，需要删除
   2. 添加到最后结果时，需要深拷贝
   3. 当用used做优化时，切记标记位的index处理，每写一行代码，都要知道其含义、影响
3. 77 组合
   利用raw回溯算法时，需要注定下边界条件
   注意每个变量的含义
   ```java
        //从start开始
        //包含n
        for (int i = start; i <= n; i ++) {
            cmb.add(i);
            // 是从i的下一个开始
            generateCombination(n, k , i + 1, cmb);
            cmb.remove(cmb.size() - 1);
        }
   ```

   注意运用剪枝
      //剪枝
        if (n - start + 1 + cmb.size() < k) {
            return;
        }
4. 79 单词路径问题，注意，不要提前return。因为当次失败了，其他回溯还可能成功
   ```java

                if (validPos(new_x, new_y) && !visited[new_x][new_y] && searchWord(board, word, index + 1, new_x, new_y)) {
                    return true;
                }
   //不能
   return searchWord();
   ```
5. 206注意，不要重复定义基础变量。
   
## 动态规划
- 递归问题
  - 重叠子问题/最優子問題
    - 记忆化搜索 自顶向下
    - 动态规划 自低向上

1. 70 就是个斐波那契
2. 343注意，一旦确认了递归函数的输入和输出，就不要打破他。比如，一下就是三项目比最大
   1. 使用向下的思路，还不算动态规划

   2. 自底向上，记忆化搜索
   
3. Jz42 Jz47 自底向上思考的dp 
4. 198 第一个递归版本，是不会通过的
      动态规划求解时，要点就是想好状态转移方程  
5. 300 LIS问题，最最重要的，仍是状态方程的定义 


